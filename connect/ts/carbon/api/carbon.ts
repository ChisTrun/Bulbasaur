/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 6.30.0
 * source: carbon/api/carbon.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../validate/validate";
import * as pb_1 from "google-protobuf";
export namespace greyhole.carbon {
    export class Logger extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            level?: Logger.Level;
            pretty?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("level" in data && data.level != undefined) {
                    this.level = data.level;
                }
                if ("pretty" in data && data.pretty != undefined) {
                    this.pretty = data.pretty;
                }
            }
        }
        get level() {
            return pb_1.Message.getFieldWithDefault(this, 1, Logger.Level.UNSPECIFIED) as Logger.Level;
        }
        set level(value: Logger.Level) {
            pb_1.Message.setField(this, 1, value);
        }
        get pretty() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set pretty(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            level?: Logger.Level;
            pretty?: boolean;
        }): Logger {
            const message = new Logger({});
            if (data.level != null) {
                message.level = data.level;
            }
            if (data.pretty != null) {
                message.pretty = data.pretty;
            }
            return message;
        }
        toObject() {
            const data: {
                level?: Logger.Level;
                pretty?: boolean;
            } = {};
            if (this.level != null) {
                data.level = this.level;
            }
            if (this.pretty != null) {
                data.pretty = this.pretty;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.level != Logger.Level.UNSPECIFIED)
                writer.writeEnum(1, this.level);
            if (this.pretty != false)
                writer.writeBool(2, this.pretty);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Logger {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Logger();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.level = reader.readEnum();
                        break;
                    case 2:
                        message.pretty = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Logger {
            return Logger.deserialize(bytes);
        }
    }
    export namespace Logger {
        export enum Level {
            UNSPECIFIED = 0,
            DEBUG = 1,
            INFO = 2,
            WARN = 3,
            ERROR = 4,
            PANIC = 5,
            FATAL = 6
        }
    }
    export class TCPSocket extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: string;
            port?: number;
            secure?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("port" in data && data.port != undefined) {
                    this.port = data.port;
                }
                if ("secure" in data && data.secure != undefined) {
                    this.secure = data.secure;
                }
            }
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get port() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set port(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get secure() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set secure(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            address?: string;
            port?: number;
            secure?: boolean;
        }): TCPSocket {
            const message = new TCPSocket({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.port != null) {
                message.port = data.port;
            }
            if (data.secure != null) {
                message.secure = data.secure;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
                port?: number;
                secure?: boolean;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.port != null) {
                data.port = this.port;
            }
            if (this.secure != null) {
                data.secure = this.secure;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address.length)
                writer.writeString(1, this.address);
            if (this.port != 0)
                writer.writeUint32(2, this.port);
            if (this.secure != false)
                writer.writeBool(3, this.secure);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TCPSocket {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TCPSocket();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    case 2:
                        message.port = reader.readUint32();
                        break;
                    case 3:
                        message.secure = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TCPSocket {
            return TCPSocket.deserialize(bytes);
        }
    }
    export class UnixSocket extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            path?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("path" in data && data.path != undefined) {
                    this.path = data.path;
                }
            }
        }
        get path() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set path(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            path?: string;
        }): UnixSocket {
            const message = new UnixSocket({});
            if (data.path != null) {
                message.path = data.path;
            }
            return message;
        }
        toObject() {
            const data: {
                path?: string;
            } = {};
            if (this.path != null) {
                data.path = this.path;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.path.length)
                writer.writeString(1, this.path);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UnixSocket {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UnixSocket();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.path = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UnixSocket {
            return UnixSocket.deserialize(bytes);
        }
    }
    export class Listener extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2]];
        constructor(data?: any[] | ({} & (({
            tcp?: TCPSocket;
            unix?: never;
        } | {
            tcp?: never;
            unix?: UnixSocket;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tcp" in data && data.tcp != undefined) {
                    this.tcp = data.tcp;
                }
                if ("unix" in data && data.unix != undefined) {
                    this.unix = data.unix;
                }
            }
        }
        get tcp() {
            return pb_1.Message.getWrapperField(this, TCPSocket, 1) as TCPSocket;
        }
        set tcp(value: TCPSocket) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_tcp() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get unix() {
            return pb_1.Message.getWrapperField(this, UnixSocket, 2) as UnixSocket;
        }
        set unix(value: UnixSocket) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_unix() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get socket() {
            const cases: {
                [index: number]: "none" | "tcp" | "unix";
            } = {
                0: "none",
                1: "tcp",
                2: "unix"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            tcp?: ReturnType<typeof TCPSocket.prototype.toObject>;
            unix?: ReturnType<typeof UnixSocket.prototype.toObject>;
        }): Listener {
            const message = new Listener({});
            if (data.tcp != null) {
                message.tcp = TCPSocket.fromObject(data.tcp);
            }
            if (data.unix != null) {
                message.unix = UnixSocket.fromObject(data.unix);
            }
            return message;
        }
        toObject() {
            const data: {
                tcp?: ReturnType<typeof TCPSocket.prototype.toObject>;
                unix?: ReturnType<typeof UnixSocket.prototype.toObject>;
            } = {};
            if (this.tcp != null) {
                data.tcp = this.tcp.toObject();
            }
            if (this.unix != null) {
                data.unix = this.unix.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_tcp)
                writer.writeMessage(1, this.tcp, () => this.tcp.serialize(writer));
            if (this.has_unix)
                writer.writeMessage(2, this.unix, () => this.unix.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Listener {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Listener();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.tcp, () => message.tcp = TCPSocket.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.unix, () => message.unix = UnixSocket.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Listener {
            return Listener.deserialize(bytes);
        }
    }
    export class Database extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            host?: string;
            port?: number;
            name?: string;
            tracing_enabled?: boolean;
            debug?: boolean;
            max_idle_conns?: number;
            max_open_conns?: number;
            conn_max_life_time?: number;
            conn_max_idle_time?: number;
            auth_method?: Database.AuthMethod;
            username?: string;
            password?: string;
            aws_region?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("host" in data && data.host != undefined) {
                    this.host = data.host;
                }
                if ("port" in data && data.port != undefined) {
                    this.port = data.port;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("tracing_enabled" in data && data.tracing_enabled != undefined) {
                    this.tracing_enabled = data.tracing_enabled;
                }
                if ("debug" in data && data.debug != undefined) {
                    this.debug = data.debug;
                }
                if ("max_idle_conns" in data && data.max_idle_conns != undefined) {
                    this.max_idle_conns = data.max_idle_conns;
                }
                if ("max_open_conns" in data && data.max_open_conns != undefined) {
                    this.max_open_conns = data.max_open_conns;
                }
                if ("conn_max_life_time" in data && data.conn_max_life_time != undefined) {
                    this.conn_max_life_time = data.conn_max_life_time;
                }
                if ("conn_max_idle_time" in data && data.conn_max_idle_time != undefined) {
                    this.conn_max_idle_time = data.conn_max_idle_time;
                }
                if ("auth_method" in data && data.auth_method != undefined) {
                    this.auth_method = data.auth_method;
                }
                if ("username" in data && data.username != undefined) {
                    this.username = data.username;
                }
                if ("password" in data && data.password != undefined) {
                    this.password = data.password;
                }
                if ("aws_region" in data && data.aws_region != undefined) {
                    this.aws_region = data.aws_region;
                }
            }
        }
        get host() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set host(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get port() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set port(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get tracing_enabled() {
            return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
        }
        set tracing_enabled(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        get debug() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set debug(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get max_idle_conns() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set max_idle_conns(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get max_open_conns() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set max_open_conns(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get conn_max_life_time() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set conn_max_life_time(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get conn_max_idle_time() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set conn_max_idle_time(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        get auth_method() {
            return pb_1.Message.getFieldWithDefault(this, 10, Database.AuthMethod.AUTH_METHOD_UNSPECIFIED) as Database.AuthMethod;
        }
        set auth_method(value: Database.AuthMethod) {
            pb_1.Message.setField(this, 10, value);
        }
        get username() {
            return pb_1.Message.getFieldWithDefault(this, 11, "") as string;
        }
        set username(value: string) {
            pb_1.Message.setField(this, 11, value);
        }
        get password() {
            return pb_1.Message.getFieldWithDefault(this, 12, "") as string;
        }
        set password(value: string) {
            pb_1.Message.setField(this, 12, value);
        }
        get aws_region() {
            return pb_1.Message.getFieldWithDefault(this, 13, "") as string;
        }
        set aws_region(value: string) {
            pb_1.Message.setField(this, 13, value);
        }
        static fromObject(data: {
            host?: string;
            port?: number;
            name?: string;
            tracing_enabled?: boolean;
            debug?: boolean;
            max_idle_conns?: number;
            max_open_conns?: number;
            conn_max_life_time?: number;
            conn_max_idle_time?: number;
            auth_method?: Database.AuthMethod;
            username?: string;
            password?: string;
            aws_region?: string;
        }): Database {
            const message = new Database({});
            if (data.host != null) {
                message.host = data.host;
            }
            if (data.port != null) {
                message.port = data.port;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.tracing_enabled != null) {
                message.tracing_enabled = data.tracing_enabled;
            }
            if (data.debug != null) {
                message.debug = data.debug;
            }
            if (data.max_idle_conns != null) {
                message.max_idle_conns = data.max_idle_conns;
            }
            if (data.max_open_conns != null) {
                message.max_open_conns = data.max_open_conns;
            }
            if (data.conn_max_life_time != null) {
                message.conn_max_life_time = data.conn_max_life_time;
            }
            if (data.conn_max_idle_time != null) {
                message.conn_max_idle_time = data.conn_max_idle_time;
            }
            if (data.auth_method != null) {
                message.auth_method = data.auth_method;
            }
            if (data.username != null) {
                message.username = data.username;
            }
            if (data.password != null) {
                message.password = data.password;
            }
            if (data.aws_region != null) {
                message.aws_region = data.aws_region;
            }
            return message;
        }
        toObject() {
            const data: {
                host?: string;
                port?: number;
                name?: string;
                tracing_enabled?: boolean;
                debug?: boolean;
                max_idle_conns?: number;
                max_open_conns?: number;
                conn_max_life_time?: number;
                conn_max_idle_time?: number;
                auth_method?: Database.AuthMethod;
                username?: string;
                password?: string;
                aws_region?: string;
            } = {};
            if (this.host != null) {
                data.host = this.host;
            }
            if (this.port != null) {
                data.port = this.port;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.tracing_enabled != null) {
                data.tracing_enabled = this.tracing_enabled;
            }
            if (this.debug != null) {
                data.debug = this.debug;
            }
            if (this.max_idle_conns != null) {
                data.max_idle_conns = this.max_idle_conns;
            }
            if (this.max_open_conns != null) {
                data.max_open_conns = this.max_open_conns;
            }
            if (this.conn_max_life_time != null) {
                data.conn_max_life_time = this.conn_max_life_time;
            }
            if (this.conn_max_idle_time != null) {
                data.conn_max_idle_time = this.conn_max_idle_time;
            }
            if (this.auth_method != null) {
                data.auth_method = this.auth_method;
            }
            if (this.username != null) {
                data.username = this.username;
            }
            if (this.password != null) {
                data.password = this.password;
            }
            if (this.aws_region != null) {
                data.aws_region = this.aws_region;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.host.length)
                writer.writeString(1, this.host);
            if (this.port != 0)
                writer.writeUint32(2, this.port);
            if (this.name.length)
                writer.writeString(3, this.name);
            if (this.tracing_enabled != false)
                writer.writeBool(4, this.tracing_enabled);
            if (this.debug != false)
                writer.writeBool(5, this.debug);
            if (this.max_idle_conns != 0)
                writer.writeUint32(6, this.max_idle_conns);
            if (this.max_open_conns != 0)
                writer.writeUint32(7, this.max_open_conns);
            if (this.conn_max_life_time != 0)
                writer.writeUint32(8, this.conn_max_life_time);
            if (this.conn_max_idle_time != 0)
                writer.writeUint32(9, this.conn_max_idle_time);
            if (this.auth_method != Database.AuthMethod.AUTH_METHOD_UNSPECIFIED)
                writer.writeEnum(10, this.auth_method);
            if (this.username.length)
                writer.writeString(11, this.username);
            if (this.password.length)
                writer.writeString(12, this.password);
            if (this.aws_region.length)
                writer.writeString(13, this.aws_region);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Database {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Database();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.host = reader.readString();
                        break;
                    case 2:
                        message.port = reader.readUint32();
                        break;
                    case 3:
                        message.name = reader.readString();
                        break;
                    case 4:
                        message.tracing_enabled = reader.readBool();
                        break;
                    case 5:
                        message.debug = reader.readBool();
                        break;
                    case 6:
                        message.max_idle_conns = reader.readUint32();
                        break;
                    case 7:
                        message.max_open_conns = reader.readUint32();
                        break;
                    case 8:
                        message.conn_max_life_time = reader.readUint32();
                        break;
                    case 9:
                        message.conn_max_idle_time = reader.readUint32();
                        break;
                    case 10:
                        message.auth_method = reader.readEnum();
                        break;
                    case 11:
                        message.username = reader.readString();
                        break;
                    case 12:
                        message.password = reader.readString();
                        break;
                    case 13:
                        message.aws_region = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Database {
            return Database.deserialize(bytes);
        }
    }
    export namespace Database {
        export enum AuthMethod {
            AUTH_METHOD_UNSPECIFIED = 0,
            AUTH_METHOD_NONE = 1,
            AUTH_METHOD_USERNAME_PASSWORD = 2,
            AUTH_METHOD_AWS_IAM = 4
        }
    }
    export class JwtSigning extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            private_key?: string;
            password?: string;
            expires_time?: number;
            issuer?: string;
            default_audience?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("private_key" in data && data.private_key != undefined) {
                    this.private_key = data.private_key;
                }
                if ("password" in data && data.password != undefined) {
                    this.password = data.password;
                }
                if ("expires_time" in data && data.expires_time != undefined) {
                    this.expires_time = data.expires_time;
                }
                if ("issuer" in data && data.issuer != undefined) {
                    this.issuer = data.issuer;
                }
                if ("default_audience" in data && data.default_audience != undefined) {
                    this.default_audience = data.default_audience;
                }
            }
        }
        get private_key() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set private_key(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get password() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set password(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get expires_time() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set expires_time(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get issuer() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set issuer(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get default_audience() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set default_audience(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            private_key?: string;
            password?: string;
            expires_time?: number;
            issuer?: string;
            default_audience?: string;
        }): JwtSigning {
            const message = new JwtSigning({});
            if (data.private_key != null) {
                message.private_key = data.private_key;
            }
            if (data.password != null) {
                message.password = data.password;
            }
            if (data.expires_time != null) {
                message.expires_time = data.expires_time;
            }
            if (data.issuer != null) {
                message.issuer = data.issuer;
            }
            if (data.default_audience != null) {
                message.default_audience = data.default_audience;
            }
            return message;
        }
        toObject() {
            const data: {
                private_key?: string;
                password?: string;
                expires_time?: number;
                issuer?: string;
                default_audience?: string;
            } = {};
            if (this.private_key != null) {
                data.private_key = this.private_key;
            }
            if (this.password != null) {
                data.password = this.password;
            }
            if (this.expires_time != null) {
                data.expires_time = this.expires_time;
            }
            if (this.issuer != null) {
                data.issuer = this.issuer;
            }
            if (this.default_audience != null) {
                data.default_audience = this.default_audience;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.private_key.length)
                writer.writeString(1, this.private_key);
            if (this.password.length)
                writer.writeString(2, this.password);
            if (this.expires_time != 0)
                writer.writeInt64(3, this.expires_time);
            if (this.issuer.length)
                writer.writeString(4, this.issuer);
            if (this.default_audience.length)
                writer.writeString(5, this.default_audience);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JwtSigning {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new JwtSigning();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.private_key = reader.readString();
                        break;
                    case 2:
                        message.password = reader.readString();
                        break;
                    case 3:
                        message.expires_time = reader.readInt64();
                        break;
                    case 4:
                        message.issuer = reader.readString();
                        break;
                    case 5:
                        message.default_audience = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): JwtSigning {
            return JwtSigning.deserialize(bytes);
        }
    }
    export class S3 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            access_key_id?: string;
            secret_access_key?: string;
            region?: string;
            bucket?: string;
            host?: string;
            endpoint_url?: string;
            provider?: S3.Provider;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("access_key_id" in data && data.access_key_id != undefined) {
                    this.access_key_id = data.access_key_id;
                }
                if ("secret_access_key" in data && data.secret_access_key != undefined) {
                    this.secret_access_key = data.secret_access_key;
                }
                if ("region" in data && data.region != undefined) {
                    this.region = data.region;
                }
                if ("bucket" in data && data.bucket != undefined) {
                    this.bucket = data.bucket;
                }
                if ("host" in data && data.host != undefined) {
                    this.host = data.host;
                }
                if ("endpoint_url" in data && data.endpoint_url != undefined) {
                    this.endpoint_url = data.endpoint_url;
                }
                if ("provider" in data && data.provider != undefined) {
                    this.provider = data.provider;
                }
            }
        }
        get access_key_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set access_key_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get secret_access_key() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set secret_access_key(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get region() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set region(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get bucket() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set bucket(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get host() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set host(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get endpoint_url() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set endpoint_url(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get provider() {
            return pb_1.Message.getFieldWithDefault(this, 7, S3.Provider.PROVIDER_UNSPECIFIED) as S3.Provider;
        }
        set provider(value: S3.Provider) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            access_key_id?: string;
            secret_access_key?: string;
            region?: string;
            bucket?: string;
            host?: string;
            endpoint_url?: string;
            provider?: S3.Provider;
        }): S3 {
            const message = new S3({});
            if (data.access_key_id != null) {
                message.access_key_id = data.access_key_id;
            }
            if (data.secret_access_key != null) {
                message.secret_access_key = data.secret_access_key;
            }
            if (data.region != null) {
                message.region = data.region;
            }
            if (data.bucket != null) {
                message.bucket = data.bucket;
            }
            if (data.host != null) {
                message.host = data.host;
            }
            if (data.endpoint_url != null) {
                message.endpoint_url = data.endpoint_url;
            }
            if (data.provider != null) {
                message.provider = data.provider;
            }
            return message;
        }
        toObject() {
            const data: {
                access_key_id?: string;
                secret_access_key?: string;
                region?: string;
                bucket?: string;
                host?: string;
                endpoint_url?: string;
                provider?: S3.Provider;
            } = {};
            if (this.access_key_id != null) {
                data.access_key_id = this.access_key_id;
            }
            if (this.secret_access_key != null) {
                data.secret_access_key = this.secret_access_key;
            }
            if (this.region != null) {
                data.region = this.region;
            }
            if (this.bucket != null) {
                data.bucket = this.bucket;
            }
            if (this.host != null) {
                data.host = this.host;
            }
            if (this.endpoint_url != null) {
                data.endpoint_url = this.endpoint_url;
            }
            if (this.provider != null) {
                data.provider = this.provider;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.access_key_id.length)
                writer.writeString(1, this.access_key_id);
            if (this.secret_access_key.length)
                writer.writeString(2, this.secret_access_key);
            if (this.region.length)
                writer.writeString(3, this.region);
            if (this.bucket.length)
                writer.writeString(4, this.bucket);
            if (this.host.length)
                writer.writeString(5, this.host);
            if (this.endpoint_url.length)
                writer.writeString(6, this.endpoint_url);
            if (this.provider != S3.Provider.PROVIDER_UNSPECIFIED)
                writer.writeEnum(7, this.provider);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): S3 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new S3();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.access_key_id = reader.readString();
                        break;
                    case 2:
                        message.secret_access_key = reader.readString();
                        break;
                    case 3:
                        message.region = reader.readString();
                        break;
                    case 4:
                        message.bucket = reader.readString();
                        break;
                    case 5:
                        message.host = reader.readString();
                        break;
                    case 6:
                        message.endpoint_url = reader.readString();
                        break;
                    case 7:
                        message.provider = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): S3 {
            return S3.deserialize(bytes);
        }
    }
    export namespace S3 {
        export enum Provider {
            PROVIDER_UNSPECIFIED = 0,
            AWS = 1,
            CUSTOM = 2
        }
    }
    export class NATS extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            url?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("url" in data && data.url != undefined) {
                    this.url = data.url;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get url() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set url(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            name?: string;
            url?: string;
        }): NATS {
            const message = new NATS({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.url != null) {
                message.url = data.url;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                url?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.url != null) {
                data.url = this.url;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.url.length)
                writer.writeString(2, this.url);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NATS {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new NATS();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.url = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): NATS {
            return NATS.deserialize(bytes);
        }
    }
    export class Profiling extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            enable?: boolean;
            port?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("enable" in data && data.enable != undefined) {
                    this.enable = data.enable;
                }
                if ("port" in data && data.port != undefined) {
                    this.port = data.port;
                }
            }
        }
        get enable() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set enable(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get port() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set port(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            enable?: boolean;
            port?: number;
        }): Profiling {
            const message = new Profiling({});
            if (data.enable != null) {
                message.enable = data.enable;
            }
            if (data.port != null) {
                message.port = data.port;
            }
            return message;
        }
        toObject() {
            const data: {
                enable?: boolean;
                port?: number;
            } = {};
            if (this.enable != null) {
                data.enable = this.enable;
            }
            if (this.port != null) {
                data.port = this.port;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.enable != false)
                writer.writeBool(1, this.enable);
            if (this.port != 0)
                writer.writeUint32(2, this.port);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Profiling {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Profiling();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.enable = reader.readBool();
                        break;
                    case 2:
                        message.port = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Profiling {
            return Profiling.deserialize(bytes);
        }
    }
    export class TLS extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            enabled?: boolean;
            cert?: string;
            key?: string;
            ca?: string;
            insecure_skip_verify?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("enabled" in data && data.enabled != undefined) {
                    this.enabled = data.enabled;
                }
                if ("cert" in data && data.cert != undefined) {
                    this.cert = data.cert;
                }
                if ("key" in data && data.key != undefined) {
                    this.key = data.key;
                }
                if ("ca" in data && data.ca != undefined) {
                    this.ca = data.ca;
                }
                if ("insecure_skip_verify" in data && data.insecure_skip_verify != undefined) {
                    this.insecure_skip_verify = data.insecure_skip_verify;
                }
            }
        }
        get enabled() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set enabled(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get cert() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set cert(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get key() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set key(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get ca() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set ca(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get insecure_skip_verify() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set insecure_skip_verify(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            enabled?: boolean;
            cert?: string;
            key?: string;
            ca?: string;
            insecure_skip_verify?: boolean;
        }): TLS {
            const message = new TLS({});
            if (data.enabled != null) {
                message.enabled = data.enabled;
            }
            if (data.cert != null) {
                message.cert = data.cert;
            }
            if (data.key != null) {
                message.key = data.key;
            }
            if (data.ca != null) {
                message.ca = data.ca;
            }
            if (data.insecure_skip_verify != null) {
                message.insecure_skip_verify = data.insecure_skip_verify;
            }
            return message;
        }
        toObject() {
            const data: {
                enabled?: boolean;
                cert?: string;
                key?: string;
                ca?: string;
                insecure_skip_verify?: boolean;
            } = {};
            if (this.enabled != null) {
                data.enabled = this.enabled;
            }
            if (this.cert != null) {
                data.cert = this.cert;
            }
            if (this.key != null) {
                data.key = this.key;
            }
            if (this.ca != null) {
                data.ca = this.ca;
            }
            if (this.insecure_skip_verify != null) {
                data.insecure_skip_verify = this.insecure_skip_verify;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.enabled != false)
                writer.writeBool(1, this.enabled);
            if (this.cert.length)
                writer.writeString(2, this.cert);
            if (this.key.length)
                writer.writeString(3, this.key);
            if (this.ca.length)
                writer.writeString(4, this.ca);
            if (this.insecure_skip_verify != false)
                writer.writeBool(5, this.insecure_skip_verify);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TLS {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TLS();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.enabled = reader.readBool();
                        break;
                    case 2:
                        message.cert = reader.readString();
                        break;
                    case 3:
                        message.key = reader.readString();
                        break;
                    case 4:
                        message.ca = reader.readString();
                        break;
                    case 5:
                        message.insecure_skip_verify = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TLS {
            return TLS.deserialize(bytes);
        }
    }
    export class Redis extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            address?: string;
            username?: string;
            password?: string;
            db?: number;
            max_retries?: number;
            min_retry_backoff?: number;
            max_retry_backoff?: number;
            dial_timeout?: number;
            read_timeout?: number;
            write_timeout?: number;
            pool_fifo?: boolean;
            pool_size?: number;
            min_idle_conns?: number;
            max_conn_age?: number;
            pool_timeout?: number;
            idle_timeout?: number;
            idle_check_frequency?: number;
            read_only?: boolean;
            tls?: TLS;
            namespace?: string;
            debug?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("username" in data && data.username != undefined) {
                    this.username = data.username;
                }
                if ("password" in data && data.password != undefined) {
                    this.password = data.password;
                }
                if ("db" in data && data.db != undefined) {
                    this.db = data.db;
                }
                if ("max_retries" in data && data.max_retries != undefined) {
                    this.max_retries = data.max_retries;
                }
                if ("min_retry_backoff" in data && data.min_retry_backoff != undefined) {
                    this.min_retry_backoff = data.min_retry_backoff;
                }
                if ("max_retry_backoff" in data && data.max_retry_backoff != undefined) {
                    this.max_retry_backoff = data.max_retry_backoff;
                }
                if ("dial_timeout" in data && data.dial_timeout != undefined) {
                    this.dial_timeout = data.dial_timeout;
                }
                if ("read_timeout" in data && data.read_timeout != undefined) {
                    this.read_timeout = data.read_timeout;
                }
                if ("write_timeout" in data && data.write_timeout != undefined) {
                    this.write_timeout = data.write_timeout;
                }
                if ("pool_fifo" in data && data.pool_fifo != undefined) {
                    this.pool_fifo = data.pool_fifo;
                }
                if ("pool_size" in data && data.pool_size != undefined) {
                    this.pool_size = data.pool_size;
                }
                if ("min_idle_conns" in data && data.min_idle_conns != undefined) {
                    this.min_idle_conns = data.min_idle_conns;
                }
                if ("max_conn_age" in data && data.max_conn_age != undefined) {
                    this.max_conn_age = data.max_conn_age;
                }
                if ("pool_timeout" in data && data.pool_timeout != undefined) {
                    this.pool_timeout = data.pool_timeout;
                }
                if ("idle_timeout" in data && data.idle_timeout != undefined) {
                    this.idle_timeout = data.idle_timeout;
                }
                if ("idle_check_frequency" in data && data.idle_check_frequency != undefined) {
                    this.idle_check_frequency = data.idle_check_frequency;
                }
                if ("read_only" in data && data.read_only != undefined) {
                    this.read_only = data.read_only;
                }
                if ("tls" in data && data.tls != undefined) {
                    this.tls = data.tls;
                }
                if ("namespace" in data && data.namespace != undefined) {
                    this.namespace = data.namespace;
                }
                if ("debug" in data && data.debug != undefined) {
                    this.debug = data.debug;
                }
            }
        }
        get address() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get username() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set username(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get password() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set password(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get db() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set db(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get max_retries() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set max_retries(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get min_retry_backoff() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set min_retry_backoff(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get max_retry_backoff() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set max_retry_backoff(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get dial_timeout() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set dial_timeout(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get read_timeout() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set read_timeout(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        get write_timeout() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set write_timeout(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get pool_fifo() {
            return pb_1.Message.getFieldWithDefault(this, 11, false) as boolean;
        }
        set pool_fifo(value: boolean) {
            pb_1.Message.setField(this, 11, value);
        }
        get pool_size() {
            return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
        }
        set pool_size(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        get min_idle_conns() {
            return pb_1.Message.getFieldWithDefault(this, 13, 0) as number;
        }
        set min_idle_conns(value: number) {
            pb_1.Message.setField(this, 13, value);
        }
        get max_conn_age() {
            return pb_1.Message.getFieldWithDefault(this, 14, 0) as number;
        }
        set max_conn_age(value: number) {
            pb_1.Message.setField(this, 14, value);
        }
        get pool_timeout() {
            return pb_1.Message.getFieldWithDefault(this, 15, 0) as number;
        }
        set pool_timeout(value: number) {
            pb_1.Message.setField(this, 15, value);
        }
        get idle_timeout() {
            return pb_1.Message.getFieldWithDefault(this, 16, 0) as number;
        }
        set idle_timeout(value: number) {
            pb_1.Message.setField(this, 16, value);
        }
        get idle_check_frequency() {
            return pb_1.Message.getFieldWithDefault(this, 17, 0) as number;
        }
        set idle_check_frequency(value: number) {
            pb_1.Message.setField(this, 17, value);
        }
        get read_only() {
            return pb_1.Message.getFieldWithDefault(this, 18, false) as boolean;
        }
        set read_only(value: boolean) {
            pb_1.Message.setField(this, 18, value);
        }
        get tls() {
            return pb_1.Message.getWrapperField(this, TLS, 19) as TLS;
        }
        set tls(value: TLS) {
            pb_1.Message.setWrapperField(this, 19, value);
        }
        get has_tls() {
            return pb_1.Message.getField(this, 19) != null;
        }
        get namespace() {
            return pb_1.Message.getFieldWithDefault(this, 20, "") as string;
        }
        set namespace(value: string) {
            pb_1.Message.setField(this, 20, value);
        }
        get debug() {
            return pb_1.Message.getFieldWithDefault(this, 21, false) as boolean;
        }
        set debug(value: boolean) {
            pb_1.Message.setField(this, 21, value);
        }
        static fromObject(data: {
            address?: string;
            username?: string;
            password?: string;
            db?: number;
            max_retries?: number;
            min_retry_backoff?: number;
            max_retry_backoff?: number;
            dial_timeout?: number;
            read_timeout?: number;
            write_timeout?: number;
            pool_fifo?: boolean;
            pool_size?: number;
            min_idle_conns?: number;
            max_conn_age?: number;
            pool_timeout?: number;
            idle_timeout?: number;
            idle_check_frequency?: number;
            read_only?: boolean;
            tls?: ReturnType<typeof TLS.prototype.toObject>;
            namespace?: string;
            debug?: boolean;
        }): Redis {
            const message = new Redis({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.username != null) {
                message.username = data.username;
            }
            if (data.password != null) {
                message.password = data.password;
            }
            if (data.db != null) {
                message.db = data.db;
            }
            if (data.max_retries != null) {
                message.max_retries = data.max_retries;
            }
            if (data.min_retry_backoff != null) {
                message.min_retry_backoff = data.min_retry_backoff;
            }
            if (data.max_retry_backoff != null) {
                message.max_retry_backoff = data.max_retry_backoff;
            }
            if (data.dial_timeout != null) {
                message.dial_timeout = data.dial_timeout;
            }
            if (data.read_timeout != null) {
                message.read_timeout = data.read_timeout;
            }
            if (data.write_timeout != null) {
                message.write_timeout = data.write_timeout;
            }
            if (data.pool_fifo != null) {
                message.pool_fifo = data.pool_fifo;
            }
            if (data.pool_size != null) {
                message.pool_size = data.pool_size;
            }
            if (data.min_idle_conns != null) {
                message.min_idle_conns = data.min_idle_conns;
            }
            if (data.max_conn_age != null) {
                message.max_conn_age = data.max_conn_age;
            }
            if (data.pool_timeout != null) {
                message.pool_timeout = data.pool_timeout;
            }
            if (data.idle_timeout != null) {
                message.idle_timeout = data.idle_timeout;
            }
            if (data.idle_check_frequency != null) {
                message.idle_check_frequency = data.idle_check_frequency;
            }
            if (data.read_only != null) {
                message.read_only = data.read_only;
            }
            if (data.tls != null) {
                message.tls = TLS.fromObject(data.tls);
            }
            if (data.namespace != null) {
                message.namespace = data.namespace;
            }
            if (data.debug != null) {
                message.debug = data.debug;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
                username?: string;
                password?: string;
                db?: number;
                max_retries?: number;
                min_retry_backoff?: number;
                max_retry_backoff?: number;
                dial_timeout?: number;
                read_timeout?: number;
                write_timeout?: number;
                pool_fifo?: boolean;
                pool_size?: number;
                min_idle_conns?: number;
                max_conn_age?: number;
                pool_timeout?: number;
                idle_timeout?: number;
                idle_check_frequency?: number;
                read_only?: boolean;
                tls?: ReturnType<typeof TLS.prototype.toObject>;
                namespace?: string;
                debug?: boolean;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.username != null) {
                data.username = this.username;
            }
            if (this.password != null) {
                data.password = this.password;
            }
            if (this.db != null) {
                data.db = this.db;
            }
            if (this.max_retries != null) {
                data.max_retries = this.max_retries;
            }
            if (this.min_retry_backoff != null) {
                data.min_retry_backoff = this.min_retry_backoff;
            }
            if (this.max_retry_backoff != null) {
                data.max_retry_backoff = this.max_retry_backoff;
            }
            if (this.dial_timeout != null) {
                data.dial_timeout = this.dial_timeout;
            }
            if (this.read_timeout != null) {
                data.read_timeout = this.read_timeout;
            }
            if (this.write_timeout != null) {
                data.write_timeout = this.write_timeout;
            }
            if (this.pool_fifo != null) {
                data.pool_fifo = this.pool_fifo;
            }
            if (this.pool_size != null) {
                data.pool_size = this.pool_size;
            }
            if (this.min_idle_conns != null) {
                data.min_idle_conns = this.min_idle_conns;
            }
            if (this.max_conn_age != null) {
                data.max_conn_age = this.max_conn_age;
            }
            if (this.pool_timeout != null) {
                data.pool_timeout = this.pool_timeout;
            }
            if (this.idle_timeout != null) {
                data.idle_timeout = this.idle_timeout;
            }
            if (this.idle_check_frequency != null) {
                data.idle_check_frequency = this.idle_check_frequency;
            }
            if (this.read_only != null) {
                data.read_only = this.read_only;
            }
            if (this.tls != null) {
                data.tls = this.tls.toObject();
            }
            if (this.namespace != null) {
                data.namespace = this.namespace;
            }
            if (this.debug != null) {
                data.debug = this.debug;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address.length)
                writer.writeString(1, this.address);
            if (this.username.length)
                writer.writeString(2, this.username);
            if (this.password.length)
                writer.writeString(3, this.password);
            if (this.db != 0)
                writer.writeInt32(4, this.db);
            if (this.max_retries != 0)
                writer.writeInt32(5, this.max_retries);
            if (this.min_retry_backoff != 0)
                writer.writeInt64(6, this.min_retry_backoff);
            if (this.max_retry_backoff != 0)
                writer.writeInt64(7, this.max_retry_backoff);
            if (this.dial_timeout != 0)
                writer.writeInt64(8, this.dial_timeout);
            if (this.read_timeout != 0)
                writer.writeInt64(9, this.read_timeout);
            if (this.write_timeout != 0)
                writer.writeInt64(10, this.write_timeout);
            if (this.pool_fifo != false)
                writer.writeBool(11, this.pool_fifo);
            if (this.pool_size != 0)
                writer.writeInt32(12, this.pool_size);
            if (this.min_idle_conns != 0)
                writer.writeInt32(13, this.min_idle_conns);
            if (this.max_conn_age != 0)
                writer.writeInt64(14, this.max_conn_age);
            if (this.pool_timeout != 0)
                writer.writeInt64(15, this.pool_timeout);
            if (this.idle_timeout != 0)
                writer.writeInt64(16, this.idle_timeout);
            if (this.idle_check_frequency != 0)
                writer.writeInt64(17, this.idle_check_frequency);
            if (this.read_only != false)
                writer.writeBool(18, this.read_only);
            if (this.has_tls)
                writer.writeMessage(19, this.tls, () => this.tls.serialize(writer));
            if (this.namespace.length)
                writer.writeString(20, this.namespace);
            if (this.debug != false)
                writer.writeBool(21, this.debug);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Redis {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Redis();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    case 2:
                        message.username = reader.readString();
                        break;
                    case 3:
                        message.password = reader.readString();
                        break;
                    case 4:
                        message.db = reader.readInt32();
                        break;
                    case 5:
                        message.max_retries = reader.readInt32();
                        break;
                    case 6:
                        message.min_retry_backoff = reader.readInt64();
                        break;
                    case 7:
                        message.max_retry_backoff = reader.readInt64();
                        break;
                    case 8:
                        message.dial_timeout = reader.readInt64();
                        break;
                    case 9:
                        message.read_timeout = reader.readInt64();
                        break;
                    case 10:
                        message.write_timeout = reader.readInt64();
                        break;
                    case 11:
                        message.pool_fifo = reader.readBool();
                        break;
                    case 12:
                        message.pool_size = reader.readInt32();
                        break;
                    case 13:
                        message.min_idle_conns = reader.readInt32();
                        break;
                    case 14:
                        message.max_conn_age = reader.readInt64();
                        break;
                    case 15:
                        message.pool_timeout = reader.readInt64();
                        break;
                    case 16:
                        message.idle_timeout = reader.readInt64();
                        break;
                    case 17:
                        message.idle_check_frequency = reader.readInt64();
                        break;
                    case 18:
                        message.read_only = reader.readBool();
                        break;
                    case 19:
                        reader.readMessage(message.tls, () => message.tls = TLS.deserialize(reader));
                        break;
                    case 20:
                        message.namespace = reader.readString();
                        break;
                    case 21:
                        message.debug = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Redis {
            return Redis.deserialize(bytes);
        }
    }
    export class Kafka extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            brokers?: string;
            tls?: TLS;
            sasl?: SASL;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("brokers" in data && data.brokers != undefined) {
                    this.brokers = data.brokers;
                }
                if ("tls" in data && data.tls != undefined) {
                    this.tls = data.tls;
                }
                if ("sasl" in data && data.sasl != undefined) {
                    this.sasl = data.sasl;
                }
            }
        }
        get brokers() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set brokers(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get tls() {
            return pb_1.Message.getWrapperField(this, TLS, 2) as TLS;
        }
        set tls(value: TLS) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_tls() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get sasl() {
            return pb_1.Message.getWrapperField(this, SASL, 3) as SASL;
        }
        set sasl(value: SASL) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_sasl() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            brokers?: string;
            tls?: ReturnType<typeof TLS.prototype.toObject>;
            sasl?: ReturnType<typeof SASL.prototype.toObject>;
        }): Kafka {
            const message = new Kafka({});
            if (data.brokers != null) {
                message.brokers = data.brokers;
            }
            if (data.tls != null) {
                message.tls = TLS.fromObject(data.tls);
            }
            if (data.sasl != null) {
                message.sasl = SASL.fromObject(data.sasl);
            }
            return message;
        }
        toObject() {
            const data: {
                brokers?: string;
                tls?: ReturnType<typeof TLS.prototype.toObject>;
                sasl?: ReturnType<typeof SASL.prototype.toObject>;
            } = {};
            if (this.brokers != null) {
                data.brokers = this.brokers;
            }
            if (this.tls != null) {
                data.tls = this.tls.toObject();
            }
            if (this.sasl != null) {
                data.sasl = this.sasl.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.brokers.length)
                writer.writeString(1, this.brokers);
            if (this.has_tls)
                writer.writeMessage(2, this.tls, () => this.tls.serialize(writer));
            if (this.has_sasl)
                writer.writeMessage(3, this.sasl, () => this.sasl.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Kafka {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Kafka();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.brokers = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.tls, () => message.tls = TLS.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.sasl, () => message.sasl = SASL.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Kafka {
            return Kafka.deserialize(bytes);
        }
    }
    export class SASL extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            mechanism?: SASL.Mechanism;
            iam?: SASL.Iam;
            scram?: SASL.Scram;
            plain?: SASL.Plain;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mechanism" in data && data.mechanism != undefined) {
                    this.mechanism = data.mechanism;
                }
                if ("iam" in data && data.iam != undefined) {
                    this.iam = data.iam;
                }
                if ("scram" in data && data.scram != undefined) {
                    this.scram = data.scram;
                }
                if ("plain" in data && data.plain != undefined) {
                    this.plain = data.plain;
                }
            }
        }
        get mechanism() {
            return pb_1.Message.getFieldWithDefault(this, 1, SASL.Mechanism.UNAUTHENTICATED) as SASL.Mechanism;
        }
        set mechanism(value: SASL.Mechanism) {
            pb_1.Message.setField(this, 1, value);
        }
        get iam() {
            return pb_1.Message.getWrapperField(this, SASL.Iam, 2) as SASL.Iam;
        }
        set iam(value: SASL.Iam) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_iam() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get scram() {
            return pb_1.Message.getWrapperField(this, SASL.Scram, 3) as SASL.Scram;
        }
        set scram(value: SASL.Scram) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_scram() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get plain() {
            return pb_1.Message.getWrapperField(this, SASL.Plain, 4) as SASL.Plain;
        }
        set plain(value: SASL.Plain) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_plain() {
            return pb_1.Message.getField(this, 4) != null;
        }
        static fromObject(data: {
            mechanism?: SASL.Mechanism;
            iam?: ReturnType<typeof SASL.Iam.prototype.toObject>;
            scram?: ReturnType<typeof SASL.Scram.prototype.toObject>;
            plain?: ReturnType<typeof SASL.Plain.prototype.toObject>;
        }): SASL {
            const message = new SASL({});
            if (data.mechanism != null) {
                message.mechanism = data.mechanism;
            }
            if (data.iam != null) {
                message.iam = SASL.Iam.fromObject(data.iam);
            }
            if (data.scram != null) {
                message.scram = SASL.Scram.fromObject(data.scram);
            }
            if (data.plain != null) {
                message.plain = SASL.Plain.fromObject(data.plain);
            }
            return message;
        }
        toObject() {
            const data: {
                mechanism?: SASL.Mechanism;
                iam?: ReturnType<typeof SASL.Iam.prototype.toObject>;
                scram?: ReturnType<typeof SASL.Scram.prototype.toObject>;
                plain?: ReturnType<typeof SASL.Plain.prototype.toObject>;
            } = {};
            if (this.mechanism != null) {
                data.mechanism = this.mechanism;
            }
            if (this.iam != null) {
                data.iam = this.iam.toObject();
            }
            if (this.scram != null) {
                data.scram = this.scram.toObject();
            }
            if (this.plain != null) {
                data.plain = this.plain.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mechanism != SASL.Mechanism.UNAUTHENTICATED)
                writer.writeEnum(1, this.mechanism);
            if (this.has_iam)
                writer.writeMessage(2, this.iam, () => this.iam.serialize(writer));
            if (this.has_scram)
                writer.writeMessage(3, this.scram, () => this.scram.serialize(writer));
            if (this.has_plain)
                writer.writeMessage(4, this.plain, () => this.plain.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SASL {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SASL();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.mechanism = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.iam, () => message.iam = SASL.Iam.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.scram, () => message.scram = SASL.Scram.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.plain, () => message.plain = SASL.Plain.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SASL {
            return SASL.deserialize(bytes);
        }
    }
    export namespace SASL {
        export enum Mechanism {
            UNAUTHENTICATED = 0,
            AWS_IAM = 1,
            SCRAM = 2,
            PLAIN = 3
        }
        export class Iam extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                access_key_id?: string;
                secret_access_key?: string;
                session_token?: string;
                region?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("access_key_id" in data && data.access_key_id != undefined) {
                        this.access_key_id = data.access_key_id;
                    }
                    if ("secret_access_key" in data && data.secret_access_key != undefined) {
                        this.secret_access_key = data.secret_access_key;
                    }
                    if ("session_token" in data && data.session_token != undefined) {
                        this.session_token = data.session_token;
                    }
                    if ("region" in data && data.region != undefined) {
                        this.region = data.region;
                    }
                }
            }
            get access_key_id() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set access_key_id(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get secret_access_key() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set secret_access_key(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get session_token() {
                return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
            }
            set session_token(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            get region() {
                return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
            }
            set region(value: string) {
                pb_1.Message.setField(this, 4, value);
            }
            static fromObject(data: {
                access_key_id?: string;
                secret_access_key?: string;
                session_token?: string;
                region?: string;
            }): Iam {
                const message = new Iam({});
                if (data.access_key_id != null) {
                    message.access_key_id = data.access_key_id;
                }
                if (data.secret_access_key != null) {
                    message.secret_access_key = data.secret_access_key;
                }
                if (data.session_token != null) {
                    message.session_token = data.session_token;
                }
                if (data.region != null) {
                    message.region = data.region;
                }
                return message;
            }
            toObject() {
                const data: {
                    access_key_id?: string;
                    secret_access_key?: string;
                    session_token?: string;
                    region?: string;
                } = {};
                if (this.access_key_id != null) {
                    data.access_key_id = this.access_key_id;
                }
                if (this.secret_access_key != null) {
                    data.secret_access_key = this.secret_access_key;
                }
                if (this.session_token != null) {
                    data.session_token = this.session_token;
                }
                if (this.region != null) {
                    data.region = this.region;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.access_key_id.length)
                    writer.writeString(1, this.access_key_id);
                if (this.secret_access_key.length)
                    writer.writeString(2, this.secret_access_key);
                if (this.session_token.length)
                    writer.writeString(3, this.session_token);
                if (this.region.length)
                    writer.writeString(4, this.region);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Iam {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Iam();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.access_key_id = reader.readString();
                            break;
                        case 2:
                            message.secret_access_key = reader.readString();
                            break;
                        case 3:
                            message.session_token = reader.readString();
                            break;
                        case 4:
                            message.region = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Iam {
                return Iam.deserialize(bytes);
            }
        }
        export class Scram extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                algorithm?: string;
                username?: string;
                password?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("algorithm" in data && data.algorithm != undefined) {
                        this.algorithm = data.algorithm;
                    }
                    if ("username" in data && data.username != undefined) {
                        this.username = data.username;
                    }
                    if ("password" in data && data.password != undefined) {
                        this.password = data.password;
                    }
                }
            }
            get algorithm() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set algorithm(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get username() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set username(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get password() {
                return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
            }
            set password(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                algorithm?: string;
                username?: string;
                password?: string;
            }): Scram {
                const message = new Scram({});
                if (data.algorithm != null) {
                    message.algorithm = data.algorithm;
                }
                if (data.username != null) {
                    message.username = data.username;
                }
                if (data.password != null) {
                    message.password = data.password;
                }
                return message;
            }
            toObject() {
                const data: {
                    algorithm?: string;
                    username?: string;
                    password?: string;
                } = {};
                if (this.algorithm != null) {
                    data.algorithm = this.algorithm;
                }
                if (this.username != null) {
                    data.username = this.username;
                }
                if (this.password != null) {
                    data.password = this.password;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.algorithm.length)
                    writer.writeString(1, this.algorithm);
                if (this.username.length)
                    writer.writeString(2, this.username);
                if (this.password.length)
                    writer.writeString(3, this.password);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Scram {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Scram();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.algorithm = reader.readString();
                            break;
                        case 2:
                            message.username = reader.readString();
                            break;
                        case 3:
                            message.password = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Scram {
                return Scram.deserialize(bytes);
            }
        }
        export class Plain extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                username?: string;
                password?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("username" in data && data.username != undefined) {
                        this.username = data.username;
                    }
                    if ("password" in data && data.password != undefined) {
                        this.password = data.password;
                    }
                }
            }
            get username() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set username(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get password() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set password(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                username?: string;
                password?: string;
            }): Plain {
                const message = new Plain({});
                if (data.username != null) {
                    message.username = data.username;
                }
                if (data.password != null) {
                    message.password = data.password;
                }
                return message;
            }
            toObject() {
                const data: {
                    username?: string;
                    password?: string;
                } = {};
                if (this.username != null) {
                    data.username = this.username;
                }
                if (this.password != null) {
                    data.password = this.password;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.username.length)
                    writer.writeString(1, this.username);
                if (this.password.length)
                    writer.writeString(2, this.password);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Plain {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Plain();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.username = reader.readString();
                            break;
                        case 2:
                            message.password = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Plain {
                return Plain.deserialize(bytes);
            }
        }
    }
}
